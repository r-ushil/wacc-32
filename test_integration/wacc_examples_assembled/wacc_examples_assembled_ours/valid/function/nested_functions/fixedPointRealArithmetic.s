.data:
.text:
.global main:
main:
Program { funcs: [Func { ident: "q", signature: FuncSig { params: [], return_type: Int }, body: Return(IntLiter(14)) }, Func { ident: "power", signature: FuncSig { params: [(Int, "base"), (Int, "amount")], return_type: Int }, body: Sequence(Declaration(Int, "result", Expr(IntLiter(1))), Sequence(While(BinaryApp(Ident("amount"), Gt, IntLiter(0)), Sequence(Assignment(Ident("result"), Expr(BinaryApp(Ident("result"), Mul, Ident("base")))), Assignment(Ident("amount"), Expr(BinaryApp(Ident("amount"), Sub, IntLiter(1)))))), Return(Ident("result")))) }, Func { ident: "f", signature: FuncSig { params: [], return_type: Int }, body: Sequence(Declaration(Int, "qq", Call("q", [])), Sequence(Declaration(Int, "f", Call("power", [IntLiter(2), Ident("qq")])), Return(Ident("f")))) }, Func { ident: "intToFixedPoint", signature: FuncSig { params: [(Int, "n")], return_type: Int }, body: Sequence(Declaration(Int, "ff", Call("f", [])), Return(BinaryApp(Ident("n"), Mul, Ident("ff")))) }, Func { ident: "fixedPointToIntRoundDown", signature: FuncSig { params: [(Int, "x")], return_type: Int }, body: Sequence(Declaration(Int, "ff", Call("f", [])), Return(BinaryApp(Ident("x"), Div, Ident("ff")))) }, Func { ident: "fixedPointToIntRoundNear", signature: FuncSig { params: [(Int, "x")], return_type: Int }, body: Sequence(Declaration(Int, "ff", Call("f", [])), If(BinaryApp(Ident("x"), Gte, IntLiter(0)), Return(BinaryApp(BinaryApp(Ident("x"), Add, BinaryApp(Ident("ff"), Div, IntLiter(2))), Div, Ident("ff"))), Return(BinaryApp(BinaryApp(Ident("x"), Sub, BinaryApp(Ident("ff"), Div, IntLiter(2))), Div, Ident("ff"))))) }, Func { ident: "add", signature: FuncSig { params: [(Int, "x1"), (Int, "x2")], return_type: Int }, body: Return(BinaryApp(Ident("x1"), Add, Ident("x2"))) }, Func { ident: "subtract", signature: FuncSig { params: [(Int, "x1"), (Int, "x2")], return_type: Int }, body: Return(BinaryApp(Ident("x1"), Sub, Ident("x2"))) }, Func { ident: "addByInt", signature: FuncSig { params: [(Int, "x"), (Int, "n")], return_type: Int }, body: Sequence(Declaration(Int, "ff", Call("f", [])), Return(BinaryApp(Ident("x"), Add, BinaryApp(Ident("n"), Mul, Ident("ff"))))) }, Func { ident: "subtractByInt", signature: FuncSig { params: [(Int, "x"), (Int, "n")], return_type: Int }, body: Sequence(Declaration(Int, "ff", Call("f", [])), Return(BinaryApp(Ident("x"), Sub, BinaryApp(Ident("n"), Mul, Ident("ff"))))) }, Func { ident: "multiply", signature: FuncSig { params: [(Int, "x1"), (Int, "x2")], return_type: Int }, body: Sequence(Declaration(Int, "ff", Call("f", [])), Return(BinaryApp(Ident("x1"), Mul, BinaryApp(Ident("x2"), Div, Ident("ff"))))) }, Func { ident: "multiplyByInt", signature: FuncSig { params: [(Int, "x"), (Int, "n")], return_type: Int }, body: Return(BinaryApp(Ident("x"), Mul, Ident("n"))) }, Func { ident: "divide", signature: FuncSig { params: [(Int, "x1"), (Int, "x2")], return_type: Int }, body: Sequence(Declaration(Int, "ff", Call("f", [])), Return(BinaryApp(Ident("x1"), Mul, BinaryApp(Ident("ff"), Div, Ident("x2"))))) }, Func { ident: "divideByInt", signature: FuncSig { params: [(Int, "x"), (Int, "n")], return_type: Int }, body: Return(BinaryApp(Ident("x"), Div, Ident("n"))) }], statement: Sequence(Declaration(Int, "n1", Expr(IntLiter(10))), Sequence(Declaration(Int, "n2", Expr(IntLiter(3))), Sequence(Print(StrLiter("Using fixed-point real: ")), Sequence(Print(Ident("n1")), Sequence(Print(StrLiter(" / ")), Sequence(Print(Ident("n2")), Sequence(Print(StrLiter(" * ")), Sequence(Print(Ident("n2")), Sequence(Print(StrLiter(" = ")), Sequence(Declaration(Int, "x", Call("intToFixedPoint", [Ident("n1")])), Sequence(Assignment(Ident("x"), Call("divideByInt", [Ident("x"), Ident("n2")])), Sequence(Assignment(Ident("x"), Call("multiplyByInt", [Ident("x"), Ident("n2")])), Sequence(Declaration(Int, "result", Call("fixedPointToIntRoundNear", [Ident("x")])), Println(Ident("result"))))))))))))))) }.generate(_, 4):
