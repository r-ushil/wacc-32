.data:
.text:
.global main:
main:
Program { funcs: [Func { ident: "chooseSymbol", signature: FuncSig { params: [], return_type: Char }, body: Sequence(Println(StrLiter("========= Tic Tac Toe ================")), Sequence(Println(StrLiter("=  Because we know you want to win   =")), Sequence(Println(StrLiter("======================================")), Sequence(Println(StrLiter("=                                    =")), Sequence(Println(StrLiter("= Who would you like to be?          =")), Sequence(Println(StrLiter("=   x  (play first)                  =")), Sequence(Println(StrLiter("=   o  (play second)                 =")), Sequence(Println(StrLiter("=   q  (quit)                        =")), Sequence(Println(StrLiter("=                                    =")), Sequence(Println(StrLiter("======================================")), Sequence(Declaration(Char, "chosen", Expr(CharLiter('\u{0}'))), Sequence(While(BinaryApp(Ident("chosen"), Eq, CharLiter('\u{0}')), Sequence(Print(StrLiter("Which symbol you would like to choose: ")), Sequence(Declaration(Char, "c", Expr(CharLiter('\u{0}'))), Sequence(Read(Ident("c")), If(BinaryApp(BinaryApp(Ident("c"), Eq, CharLiter('x')), Or, BinaryApp(Ident("c"), Eq, CharLiter('X'))), Assignment(Ident("chosen"), Expr(CharLiter('x'))), If(BinaryApp(BinaryApp(Ident("c"), Eq, CharLiter('o')), Or, BinaryApp(Ident("c"), Eq, CharLiter('O'))), Assignment(Ident("chosen"), Expr(CharLiter('o'))), If(BinaryApp(BinaryApp(Ident("c"), Eq, CharLiter('q')), Or, BinaryApp(Ident("c"), Eq, CharLiter('Q'))), Sequence(Println(StrLiter("Goodbye safety.")), Exit(IntLiter(0))), Sequence(Print(StrLiter("Invalid symbol: ")), Sequence(Println(Ident("c")), Println(StrLiter("Please try again."))))))))))), Sequence(Print(StrLiter("You have chosen: ")), Sequence(Println(Ident("chosen")), Return(Ident("chosen")))))))))))))))) }, Func { ident: "printBoard", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("board")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row3", PairElem(Snd(Ident("board")))), Sequence(Println(StrLiter(" 1 2 3")), Sequence(Print(StrLiter("1")), Sequence(Declaration(Bool, "_", Call("printRow", [Ident("row1")])), Sequence(Println(StrLiter(" -+-+-")), Sequence(Print(StrLiter("2")), Sequence(Assignment(Ident("_"), Call("printRow", [Ident("row2")])), Sequence(Println(StrLiter(" -+-+-")), Sequence(Print(StrLiter("3")), Sequence(Assignment(Ident("_"), Call("printRow", [Ident("row3")])), Sequence(Println(StrLiter("")), Return(BoolLiter(true)))))))))))))))) }, Func { ident: "printRow", signature: FuncSig { params: [(Pair(Pair(Any, Any), Char), "row")], return_type: Bool }, body: Sequence(Declaration(Pair(Char, Char), "front", PairElem(Fst(Ident("row")))), Sequence(Declaration(Char, "cell1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Char, "cell2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Char, "cell3", PairElem(Snd(Ident("row")))), Sequence(Declaration(Bool, "_", Call("printCell", [Ident("cell1")])), Sequence(Print(CharLiter('|')), Sequence(Assignment(Ident("_"), Call("printCell", [Ident("cell2")])), Sequence(Print(CharLiter('|')), Sequence(Assignment(Ident("_"), Call("printCell", [Ident("cell3")])), Sequence(Println(StrLiter("")), Return(BoolLiter(true)))))))))))) }, Func { ident: "printCell", signature: FuncSig { params: [(Char, "cell")], return_type: Bool }, body: Sequence(If(BinaryApp(Ident("cell"), Eq, CharLiter('\u{0}')), Print(CharLiter(' ')), Print(Ident("cell"))), Return(BoolLiter(true))) }, Func { ident: "askForAMoveHuman", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Array(Int), "move")], return_type: Bool }, body: Sequence(Declaration(Bool, "success", Expr(BoolLiter(false))), Sequence(Declaration(Int, "row", Expr(IntLiter(0))), Sequence(Declaration(Int, "column", Expr(IntLiter(0))), Sequence(While(UnaryApp(Bang, Ident("success")), Sequence(Println(StrLiter("What is your next move?")), Sequence(Print(StrLiter(" row (1-3): ")), Sequence(Read(Ident("row")), Sequence(Print(StrLiter(" column (1-3): ")), Sequence(Read(Ident("column")), Sequence(Assignment(Ident("success"), Call("validateMove", [Ident("board"), Ident("row"), Ident("column")])), If(Ident("success"), Sequence(Println(StrLiter("")), Sequence(Assignment(ArrayElem(ArrayElem("move", [IntLiter(0)])), Expr(Ident("row"))), Sequence(Assignment(ArrayElem(ArrayElem("move", [IntLiter(1)])), Expr(Ident("column"))), Return(BoolLiter(true))))), Println(StrLiter("Your move is invalid. Please try again.")))))))))), Return(BoolLiter(true)))))) }, Func { ident: "validateMove", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Int, "moveRow"), (Int, "moveColumn")], return_type: Bool }, body: If(BinaryApp(BinaryApp(IntLiter(1), Lte, Ident("moveRow")), And, BinaryApp(BinaryApp(Ident("moveRow"), Lte, IntLiter(3)), And, BinaryApp(BinaryApp(IntLiter(1), Lte, Ident("moveColumn")), And, BinaryApp(Ident("moveColumn"), Lte, IntLiter(3))))), Sequence(Declaration(Char, "sym", Call("symbolAt", [Ident("board"), Ident("moveRow"), Ident("moveColumn")])), Return(BinaryApp(Ident("sym"), Eq, CharLiter('\u{0}')))), Return(BoolLiter(false))) }, Func { ident: "notifyMoveHuman", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Char, "currentTurn"), (Char, "playerSymbol"), (Int, "moveRow"), (Int, "moveColumn")], return_type: Bool }, body: Sequence(Print(StrLiter("The AI played at row ")), Sequence(Print(Ident("moveRow")), Sequence(Print(StrLiter(" column ")), Sequence(Println(Ident("moveColumn")), Return(BoolLiter(true)))))) }, Func { ident: "initAI", signature: FuncSig { params: [(Char, "aiSymbol")], return_type: Pair(Pair(Any, Any), Pair(Any, Any)) }, body: Sequence(Declaration(Pair(Char, Pair(Any, Any)), "info", Pair(Ident("aiSymbol"), PairLiter)), Sequence(Declaration(Pair(Pair(Any, Any), Int), "stateTree", Call("generateAllPossibleStates", [Ident("aiSymbol")])), Sequence(Declaration(Int, "value", Call("setValuesForAllStates", [Ident("stateTree"), Ident("aiSymbol"), CharLiter('x')])), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "aiData", Pair(Ident("info"), Ident("stateTree"))), Return(Ident("aiData")))))) }, Func { ident: "generateAllPossibleStates", signature: FuncSig { params: [(Char, "aiSymbol")], return_type: Pair(Pair(Any, Any), Int) }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "board", Call("allocateNewBoard", [])), Sequence(Declaration(Pair(Pair(Any, Any), Int), "rootState", Call("convertFromBoardToState", [Ident("board")])), Sequence(Assignment(Ident("rootState"), Call("generateNextStates", [Ident("rootState"), CharLiter('x')])), Return(Ident("rootState"))))) }, Func { ident: "convertFromBoardToState", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board")], return_type: Pair(Pair(Any, Any), Int) }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers", Call("generateEmptyPointerBoard", [])), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", Pair(Ident("board"), Ident("pointers"))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "state", Pair(Ident("front"), IntLiter(0))), Return(Ident("state"))))) }, Func { ident: "generateEmptyPointerBoard", signature: FuncSig { params: [], return_type: Pair(Pair(Any, Any), Pair(Any, Any)) }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row1", Call("generateEmptyPointerRow", [])), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row2", Call("generateEmptyPointerRow", [])), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row3", Call("generateEmptyPointerRow", [])), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", Pair(Ident("row1"), Ident("row2"))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "root", Pair(Ident("front"), Ident("row3"))), Return(Ident("root"))))))) }, Func { ident: "generateEmptyPointerRow", signature: FuncSig { params: [], return_type: Pair(Pair(Any, Any), Pair(Any, Any)) }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", Pair(PairLiter, PairLiter)), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "root", Pair(Ident("front"), PairLiter)), Return(Ident("root")))) }, Func { ident: "generateNextStates", signature: FuncSig { params: [(Pair(Pair(Any, Any), Int), "state"), (Char, "currentPlayer")], return_type: Pair(Pair(Any, Any), Int) }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("state")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "board", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers", PairElem(Snd(Ident("front")))), Sequence(Declaration(Char, "previousPlayer", Call("oppositeSymbol", [Ident("currentPlayer")])), Sequence(Declaration(Bool, "won", Call("hasWon", [Ident("board"), Ident("previousPlayer")])), If(Ident("won"), Return(Ident("state")), Sequence(Declaration(Bool, "_", Call("generateNextStatesBoard", [Ident("board"), Ident("pointers"), Ident("currentPlayer")])), Return(Ident("state"))))))))) }, Func { ident: "generateNextStatesBoard", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Pair(Pair(Any, Any), Pair(Any, Any)), "pointers"), (Char, "currentPlayer")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("board")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row3", PairElem(Snd(Ident("board")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "frontP", PairElem(Fst(Ident("pointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row1P", PairElem(Fst(Ident("frontP")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row2P", PairElem(Snd(Ident("frontP")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row3P", PairElem(Snd(Ident("pointers")))), Sequence(Declaration(Bool, "_", Call("generateNextStatesRow", [Ident("board"), Ident("row1"), Ident("row1P"), Ident("currentPlayer"), IntLiter(1)])), Sequence(Assignment(Ident("_"), Call("generateNextStatesRow", [Ident("board"), Ident("row2"), Ident("row2P"), Ident("currentPlayer"), IntLiter(2)])), Sequence(Assignment(Ident("_"), Call("generateNextStatesRow", [Ident("board"), Ident("row3"), Ident("row3P"), Ident("currentPlayer"), IntLiter(3)])), Return(BoolLiter(true))))))))))))) }, Func { ident: "generateNextStatesRow", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Pair(Pair(Any, Any), Char), "row"), (Pair(Pair(Any, Any), Pair(Any, Any)), "pointerRow"), (Char, "currentPlayer"), (Int, "rowNumber")], return_type: Bool }, body: Sequence(Declaration(Pair(Char, Char), "front", PairElem(Fst(Ident("row")))), Sequence(Declaration(Char, "cell1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Char, "cell2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Char, "cell3", PairElem(Snd(Ident("row")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "frontP", PairElem(Fst(Ident("pointerRow")))), Sequence(Assignment(PairElem(Fst(Ident("frontP"))), Call("generateNextStatesCell", [Ident("board"), Ident("cell1"), Ident("currentPlayer"), Ident("rowNumber"), IntLiter(1)])), Sequence(Assignment(PairElem(Snd(Ident("frontP"))), Call("generateNextStatesCell", [Ident("board"), Ident("cell2"), Ident("currentPlayer"), Ident("rowNumber"), IntLiter(2)])), Sequence(Assignment(PairElem(Snd(Ident("pointerRow"))), Call("generateNextStatesCell", [Ident("board"), Ident("cell3"), Ident("currentPlayer"), Ident("rowNumber"), IntLiter(3)])), Return(BoolLiter(true)))))))))) }, Func { ident: "generateNextStatesCell", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Char, "cell"), (Char, "currentPlayer"), (Int, "rowNumber"), (Int, "columnNumber")], return_type: Pair(Pair(Any, Any), Int) }, body: If(BinaryApp(Ident("cell"), Eq, CharLiter('\u{0}')), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "board2", Call("cloneBoard", [Ident("board")])), Sequence(Declaration(Bool, "_", Call("placeMove", [Ident("board2"), Ident("currentPlayer"), Ident("rowNumber"), Ident("columnNumber")])), Sequence(Declaration(Pair(Pair(Any, Any), Int), "state", Call("convertFromBoardToState", [Ident("board2")])), Sequence(Declaration(Char, "nextPlayer", Call("oppositeSymbol", [Ident("currentPlayer")])), Sequence(Assignment(Ident("state"), Call("generateNextStates", [Ident("state"), Ident("nextPlayer")])), Return(Ident("state"))))))), Return(PairLiter)) }, Func { ident: "cloneBoard", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board")], return_type: Pair(Pair(Any, Any), Pair(Any, Any)) }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "board2", Call("allocateNewBoard", [])), Sequence(Declaration(Bool, "_", Call("copyBoard", [Ident("board"), Ident("board2")])), Return(Ident("board2")))) }, Func { ident: "copyBoard", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "from"), (Pair(Pair(Any, Any), Pair(Any, Any)), "to")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "frontFrom", PairElem(Fst(Ident("from")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row1From", PairElem(Fst(Ident("frontFrom")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row2From", PairElem(Snd(Ident("frontFrom")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row3From", PairElem(Snd(Ident("from")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "frontTo", PairElem(Fst(Ident("to")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row1To", PairElem(Fst(Ident("frontTo")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row2To", PairElem(Snd(Ident("frontTo")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row3To", PairElem(Snd(Ident("to")))), Sequence(Declaration(Bool, "_", Call("copyRow", [Ident("row1From"), Ident("row1To")])), Sequence(Assignment(Ident("_"), Call("copyRow", [Ident("row2From"), Ident("row2To")])), Sequence(Assignment(Ident("_"), Call("copyRow", [Ident("row3From"), Ident("row3To")])), Return(BoolLiter(true))))))))))))) }, Func { ident: "copyRow", signature: FuncSig { params: [(Pair(Pair(Any, Any), Char), "from"), (Pair(Pair(Any, Any), Char), "to")], return_type: Bool }, body: Sequence(Declaration(Pair(Char, Char), "frontFrom", PairElem(Fst(Ident("from")))), Sequence(Declaration(Pair(Char, Char), "frontTo", PairElem(Fst(Ident("to")))), Sequence(Assignment(PairElem(Fst(Ident("frontTo"))), PairElem(Fst(Ident("frontFrom")))), Sequence(Assignment(PairElem(Snd(Ident("frontTo"))), PairElem(Snd(Ident("frontFrom")))), Sequence(Assignment(PairElem(Snd(Ident("to"))), PairElem(Snd(Ident("from")))), Return(BoolLiter(true))))))) }, Func { ident: "setValuesForAllStates", signature: FuncSig { params: [(Pair(Pair(Any, Any), Int), "state"), (Char, "aiSymbol"), (Char, "currentPlayer")], return_type: Int }, body: Sequence(Declaration(Int, "outValue", Expr(IntLiter(0))), Sequence(If(BinaryApp(Ident("state"), Eq, PairLiter), If(BinaryApp(Ident("currentPlayer"), Eq, Ident("aiSymbol")), Assignment(Ident("outValue"), Expr(IntLiter(101))), Assignment(Ident("outValue"), Expr(IntLiter(-101)))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("state")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "board", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers", PairElem(Snd(Ident("front")))), Sequence(Declaration(Char, "anotherPlayer", Call("oppositeSymbol", [Ident("currentPlayer")])), Sequence(Declaration(Bool, "won", Call("hasWon", [Ident("board"), Ident("anotherPlayer")])), Sequence(If(Ident("won"), If(BinaryApp(Ident("anotherPlayer"), Eq, Ident("aiSymbol")), Assignment(Ident("outValue"), Expr(IntLiter(100))), Assignment(Ident("outValue"), Expr(IntLiter(-100)))), Sequence(Declaration(Bool, "hasEmptyCell", Call("containEmptyCell", [Ident("board")])), If(Ident("hasEmptyCell"), Sequence(Assignment(Ident("outValue"), Call("calculateValuesFromNextStates", [Ident("pointers"), Ident("aiSymbol"), Ident("anotherPlayer")])), If(BinaryApp(Ident("outValue"), Eq, IntLiter(100)), Assignment(Ident("outValue"), Expr(IntLiter(90))), Skip)), Assignment(Ident("outValue"), Expr(IntLiter(0)))))), Assignment(PairElem(Snd(Ident("state"))), Expr(Ident("outValue")))))))))), Return(Ident("outValue")))) }, Func { ident: "calculateValuesFromNextStates", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers"), (Char, "aiSymbol"), (Char, "playerOfNextState")], return_type: Int }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("pointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row3", PairElem(Snd(Ident("pointers")))), Sequence(Declaration(Int, "value1", Call("calculateValuesFromNextStatesRow", [Ident("row1"), Ident("aiSymbol"), Ident("playerOfNextState")])), Sequence(Declaration(Int, "value2", Call("calculateValuesFromNextStatesRow", [Ident("row2"), Ident("aiSymbol"), Ident("playerOfNextState")])), Sequence(Declaration(Int, "value3", Call("calculateValuesFromNextStatesRow", [Ident("row3"), Ident("aiSymbol"), Ident("playerOfNextState")])), Sequence(Declaration(Int, "out", Call("combineValue", [Ident("aiSymbol"), Ident("playerOfNextState"), Ident("value1"), Ident("value2"), Ident("value3")])), Return(Ident("out")))))))))) }, Func { ident: "calculateValuesFromNextStatesRow", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "rowPointers"), (Char, "aiSymbol"), (Char, "playerOfNextState")], return_type: Int }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("rowPointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "state1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "state2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "state3", PairElem(Snd(Ident("rowPointers")))), Sequence(Declaration(Int, "value1", Call("setValuesForAllStates", [Ident("state1"), Ident("aiSymbol"), Ident("playerOfNextState")])), Sequence(Declaration(Int, "value2", Call("setValuesForAllStates", [Ident("state2"), Ident("aiSymbol"), Ident("playerOfNextState")])), Sequence(Declaration(Int, "value3", Call("setValuesForAllStates", [Ident("state3"), Ident("aiSymbol"), Ident("playerOfNextState")])), Sequence(Declaration(Int, "out", Call("combineValue", [Ident("aiSymbol"), Ident("playerOfNextState"), Ident("value1"), Ident("value2"), Ident("value3")])), Return(Ident("out")))))))))) }, Func { ident: "combineValue", signature: FuncSig { params: [(Char, "aiSymbol"), (Char, "playerOfNextState"), (Int, "value1"), (Int, "value2"), (Int, "value3")], return_type: Int }, body: Sequence(Declaration(Int, "out", Expr(IntLiter(0))), Sequence(If(BinaryApp(Ident("aiSymbol"), Eq, Ident("playerOfNextState")), Assignment(Ident("out"), Call("min3", [Ident("value1"), Ident("value2"), Ident("value3")])), Assignment(Ident("out"), Call("max3", [Ident("value1"), Ident("value2"), Ident("value3")]))), Return(Ident("out")))) }, Func { ident: "min3", signature: FuncSig { params: [(Int, "a"), (Int, "b"), (Int, "c")], return_type: Int }, body: If(BinaryApp(Ident("a"), Lt, Ident("b")), If(BinaryApp(Ident("a"), Lt, Ident("c")), Return(Ident("a")), Return(Ident("c"))), If(BinaryApp(Ident("b"), Lt, Ident("c")), Return(Ident("b")), Return(Ident("c")))) }, Func { ident: "max3", signature: FuncSig { params: [(Int, "a"), (Int, "b"), (Int, "c")], return_type: Int }, body: If(BinaryApp(Ident("a"), Gt, Ident("b")), If(BinaryApp(Ident("a"), Gt, Ident("c")), Return(Ident("a")), Return(Ident("c"))), If(BinaryApp(Ident("b"), Gt, Ident("c")), Return(Ident("b")), Return(Ident("c")))) }, Func { ident: "destroyAI", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "aiData")], return_type: Bool }, body: Sequence(Declaration(Pair(Char, Pair(Any, Any)), "info", PairElem(Fst(Ident("aiData")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "stateTree", PairElem(Snd(Ident("aiData")))), Sequence(Declaration(Bool, "_", Call("deleteStateTreeRecursively", [Ident("stateTree")])), Sequence(Free(Ident("info")), Sequence(Free(Ident("aiData")), Return(BoolLiter(true))))))) }, Func { ident: "askForAMoveAI", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Char, "currentTurn"), (Char, "playerSymbol"), (Pair(Pair(Any, Any), Pair(Any, Any)), "aiData"), (Array(Int), "move")], return_type: Bool }, body: Sequence(Declaration(Pair(Char, Pair(Any, Any)), "info", PairElem(Fst(Ident("aiData")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "stateTree", PairElem(Snd(Ident("aiData")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("stateTree")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers", PairElem(Snd(Ident("front")))), Sequence(Declaration(Int, "stateValue", PairElem(Snd(Ident("stateTree")))), Sequence(Declaration(Bool, "_", Call("findTheBestMove", [Ident("pointers"), Ident("stateValue"), Ident("move")])), Sequence(Println(StrLiter("AI is cleaning up its memory...")), Sequence(Assignment(PairElem(Snd(Ident("aiData"))), Call("deleteAllOtherChildren", [Ident("pointers"), ArrayElem(ArrayElem("move", [IntLiter(0)])), ArrayElem(ArrayElem("move", [IntLiter(1)]))])), Sequence(Assignment(Ident("_"), Call("deleteThisStateOnly", [Ident("stateTree")])), Return(BoolLiter(true))))))))))) }, Func { ident: "findTheBestMove", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers"), (Int, "stateValue"), (Array(Int), "move")], return_type: Bool }, body: Sequence(If(BinaryApp(Ident("stateValue"), Eq, IntLiter(90)), Sequence(Declaration(Bool, "found", Call("findMoveWithGivenValue", [Ident("pointers"), IntLiter(100), Ident("move")])), If(Ident("found"), Return(BoolLiter(true)), Skip)), Skip), Sequence(Declaration(Bool, "found", Call("findMoveWithGivenValue", [Ident("pointers"), Ident("stateValue"), Ident("move")])), If(Ident("found"), Return(BoolLiter(true)), Sequence(Println(StrLiter("Internal Error: cannot find the next move for the AI")), Exit(IntLiter(-1)))))) }, Func { ident: "findMoveWithGivenValue", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers"), (Int, "stateValue"), (Array(Int), "move")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("pointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row3", PairElem(Snd(Ident("pointers")))), Sequence(Declaration(Bool, "find", Call("findMoveWithGivenValueRow", [Ident("row1"), Ident("stateValue"), Ident("move")])), Sequence(If(Ident("find"), Assignment(ArrayElem(ArrayElem("move", [IntLiter(0)])), Expr(IntLiter(1))), Sequence(Assignment(Ident("find"), Call("findMoveWithGivenValueRow", [Ident("row2"), Ident("stateValue"), Ident("move")])), If(Ident("find"), Assignment(ArrayElem(ArrayElem("move", [IntLiter(0)])), Expr(IntLiter(2))), Sequence(Assignment(Ident("find"), Call("findMoveWithGivenValueRow", [Ident("row3"), Ident("stateValue"), Ident("move")])), If(Ident("find"), Assignment(ArrayElem(ArrayElem("move", [IntLiter(0)])), Expr(IntLiter(3))), Return(BoolLiter(false))))))), Return(BoolLiter(true)))))))) }, Func { ident: "findMoveWithGivenValueRow", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "rowPointers"), (Int, "stateValue"), (Array(Int), "move")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("rowPointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "cell1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "cell2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "cell3", PairElem(Snd(Ident("rowPointers")))), Sequence(Declaration(Bool, "find", Call("hasGivenStateValue", [Ident("cell1"), Ident("stateValue")])), Sequence(If(Ident("find"), Assignment(ArrayElem(ArrayElem("move", [IntLiter(1)])), Expr(IntLiter(1))), Sequence(Assignment(Ident("find"), Call("hasGivenStateValue", [Ident("cell2"), Ident("stateValue")])), If(Ident("find"), Assignment(ArrayElem(ArrayElem("move", [IntLiter(1)])), Expr(IntLiter(2))), Sequence(Assignment(Ident("find"), Call("hasGivenStateValue", [Ident("cell3"), Ident("stateValue")])), If(Ident("find"), Assignment(ArrayElem(ArrayElem("move", [IntLiter(1)])), Expr(IntLiter(3))), Return(BoolLiter(false))))))), Return(BoolLiter(true)))))))) }, Func { ident: "hasGivenStateValue", signature: FuncSig { params: [(Pair(Pair(Any, Any), Int), "state"), (Int, "stateValue")], return_type: Bool }, body: If(BinaryApp(Ident("state"), Eq, PairLiter), Return(BoolLiter(false)), Sequence(Declaration(Int, "actual", PairElem(Snd(Ident("state")))), Return(BinaryApp(Ident("actual"), Eq, Ident("stateValue"))))) }, Func { ident: "notifyMoveAI", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Char, "currentTurn"), (Char, "playerSymbol"), (Pair(Pair(Any, Any), Pair(Any, Any)), "aiData"), (Int, "moveRow"), (Int, "moveColumn")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Int), "stateTree", PairElem(Snd(Ident("aiData")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("stateTree")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers", PairElem(Snd(Ident("front")))), Sequence(Println(StrLiter("AI is cleaning up its memory...")), Sequence(Assignment(PairElem(Snd(Ident("aiData"))), Call("deleteAllOtherChildren", [Ident("pointers"), Ident("moveRow"), Ident("moveColumn")])), Sequence(Declaration(Bool, "_", Call("deleteThisStateOnly", [Ident("stateTree")])), Return(BoolLiter(true)))))))) }, Func { ident: "deleteAllOtherChildren", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers"), (Int, "moveRow"), (Int, "moveColumn")], return_type: Pair(Pair(Any, Any), Int) }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("pointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row3", PairElem(Snd(Ident("pointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "toKeepRow", Expr(PairLiter)), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "toDeleteRow1", Expr(PairLiter)), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "toDeleteRow2", Expr(PairLiter)), Sequence(If(BinaryApp(Ident("moveRow"), Eq, IntLiter(1)), Sequence(Assignment(Ident("toKeepRow"), Expr(Ident("row1"))), Sequence(Assignment(Ident("toDeleteRow1"), Expr(Ident("row2"))), Assignment(Ident("toDeleteRow2"), Expr(Ident("row3"))))), Sequence(Assignment(Ident("toDeleteRow1"), Expr(Ident("row1"))), If(BinaryApp(Ident("moveRow"), Eq, IntLiter(2)), Sequence(Assignment(Ident("toKeepRow"), Expr(Ident("row2"))), Assignment(Ident("toDeleteRow2"), Expr(Ident("row3")))), Sequence(Assignment(Ident("toKeepRow"), Expr(Ident("row3"))), Assignment(Ident("toDeleteRow2"), Expr(Ident("row2"))))))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "out", Call("deleteAllOtherChildrenRow", [Ident("toKeepRow"), Ident("moveColumn")])), Sequence(Declaration(Bool, "_", Call("deleteChildrenStateRecursivelyRow", [Ident("toDeleteRow1")])), Sequence(Assignment(Ident("_"), Call("deleteChildrenStateRecursivelyRow", [Ident("toDeleteRow2")])), Return(Ident("out"))))))))))))) }, Func { ident: "deleteAllOtherChildrenRow", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "rowPointers"), (Int, "moveColumn")], return_type: Pair(Pair(Any, Any), Int) }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("rowPointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "cell1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "cell2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "cell3", PairElem(Snd(Ident("rowPointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "toKeepCell", Expr(PairLiter)), Sequence(Declaration(Pair(Pair(Any, Any), Int), "toDeleteCell1", Expr(PairLiter)), Sequence(Declaration(Pair(Pair(Any, Any), Int), "toDeleteCell2", Expr(PairLiter)), Sequence(If(BinaryApp(Ident("moveColumn"), Eq, IntLiter(1)), Sequence(Assignment(Ident("toKeepCell"), Expr(Ident("cell1"))), Sequence(Assignment(Ident("toDeleteCell1"), Expr(Ident("cell2"))), Assignment(Ident("toDeleteCell2"), Expr(Ident("cell3"))))), Sequence(Assignment(Ident("toDeleteCell1"), Expr(Ident("cell1"))), If(BinaryApp(Ident("moveColumn"), Eq, IntLiter(2)), Sequence(Assignment(Ident("toKeepCell"), Expr(Ident("cell2"))), Assignment(Ident("toDeleteCell2"), Expr(Ident("cell3")))), Sequence(Assignment(Ident("toKeepCell"), Expr(Ident("cell3"))), Assignment(Ident("toDeleteCell2"), Expr(Ident("cell2"))))))), Sequence(Declaration(Bool, "_", Call("deleteStateTreeRecursively", [Ident("toDeleteCell1")])), Sequence(Assignment(Ident("_"), Call("deleteStateTreeRecursively", [Ident("toDeleteCell2")])), Return(Ident("toKeepCell")))))))))))) }, Func { ident: "deleteStateTreeRecursively", signature: FuncSig { params: [(Pair(Pair(Any, Any), Int), "stateTree")], return_type: Bool }, body: If(BinaryApp(Ident("stateTree"), Eq, PairLiter), Return(BoolLiter(true)), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("stateTree")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "board", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers", PairElem(Snd(Ident("front")))), Sequence(Declaration(Bool, "_", Call("deleteChildrenStateRecursively", [Ident("pointers")])), Sequence(Assignment(Ident("_"), Call("deleteThisStateOnly", [Ident("stateTree")])), Return(BoolLiter(true)))))))) }, Func { ident: "deleteThisStateOnly", signature: FuncSig { params: [(Pair(Pair(Any, Any), Int), "stateTree")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("stateTree")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "board", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers", PairElem(Snd(Ident("front")))), Sequence(Declaration(Bool, "_", Call("freeBoard", [Ident("board")])), Sequence(Assignment(Ident("_"), Call("freePointers", [Ident("pointers")])), Sequence(Free(Ident("front")), Sequence(Free(Ident("stateTree")), Return(BoolLiter(true))))))))) }, Func { ident: "freePointers", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("pointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row3", PairElem(Snd(Ident("pointers")))), Sequence(Declaration(Bool, "_", Call("freePointersRow", [Ident("row1")])), Sequence(Assignment(Ident("_"), Call("freePointersRow", [Ident("row2")])), Sequence(Assignment(Ident("_"), Call("freePointersRow", [Ident("row3")])), Sequence(Free(Ident("front")), Sequence(Free(Ident("pointers")), Return(BoolLiter(true))))))))))) }, Func { ident: "freePointersRow", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "rowPointers")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("rowPointers")))), Sequence(Free(Ident("front")), Sequence(Free(Ident("rowPointers")), Return(BoolLiter(true))))) }, Func { ident: "deleteChildrenStateRecursively", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("pointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row3", PairElem(Snd(Ident("pointers")))), Sequence(Declaration(Bool, "_", Call("deleteChildrenStateRecursivelyRow", [Ident("row1")])), Sequence(Assignment(Ident("_"), Call("deleteChildrenStateRecursivelyRow", [Ident("row2")])), Sequence(Assignment(Ident("_"), Call("deleteChildrenStateRecursivelyRow", [Ident("row3")])), Return(BoolLiter(true))))))))) }, Func { ident: "deleteChildrenStateRecursivelyRow", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "rowPointers")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("rowPointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "cell1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "cell2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "cell3", PairElem(Snd(Ident("rowPointers")))), Sequence(Declaration(Bool, "_", Call("deleteStateTreeRecursively", [Ident("cell1")])), Sequence(Assignment(Ident("_"), Call("deleteStateTreeRecursively", [Ident("cell2")])), Sequence(Assignment(Ident("_"), Call("deleteStateTreeRecursively", [Ident("cell3")])), Return(BoolLiter(true))))))))) }, Func { ident: "askForAMove", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Char, "currentTurn"), (Char, "playerSymbol"), (Pair(Pair(Any, Any), Pair(Any, Any)), "aiData"), (Array(Int), "move")], return_type: Bool }, body: Sequence(If(BinaryApp(Ident("currentTurn"), Eq, Ident("playerSymbol")), Declaration(Bool, "_", Call("askForAMoveHuman", [Ident("board"), Ident("move")])), Declaration(Bool, "_", Call("askForAMoveAI", [Ident("board"), Ident("currentTurn"), Ident("playerSymbol"), Ident("aiData"), Ident("move")]))), Return(BoolLiter(true))) }, Func { ident: "placeMove", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Char, "currentTurn"), (Int, "moveRow"), (Int, "moveColumn")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Char), "targetRow", Expr(PairLiter)), Sequence(If(BinaryApp(Ident("moveRow"), Lte, IntLiter(2)), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("board")))), If(BinaryApp(Ident("moveRow"), Eq, IntLiter(1)), Assignment(Ident("targetRow"), PairElem(Fst(Ident("front")))), Assignment(Ident("targetRow"), PairElem(Snd(Ident("front")))))), Assignment(Ident("targetRow"), PairElem(Snd(Ident("board"))))), Sequence(If(BinaryApp(Ident("moveColumn"), Lte, IntLiter(2)), Sequence(Declaration(Pair(Char, Char), "front", PairElem(Fst(Ident("targetRow")))), If(BinaryApp(Ident("moveColumn"), Eq, IntLiter(1)), Assignment(PairElem(Fst(Ident("front"))), Expr(Ident("currentTurn"))), Assignment(PairElem(Snd(Ident("front"))), Expr(Ident("currentTurn"))))), Assignment(PairElem(Snd(Ident("targetRow"))), Expr(Ident("currentTurn")))), Return(BoolLiter(true))))) }, Func { ident: "notifyMove", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Char, "currentTurn"), (Char, "playerSymbol"), (Pair(Pair(Any, Any), Pair(Any, Any)), "aiData"), (Int, "moveRow"), (Int, "moveColumn")], return_type: Bool }, body: Sequence(If(BinaryApp(Ident("currentTurn"), Eq, Ident("playerSymbol")), Declaration(Bool, "_", Call("notifyMoveAI", [Ident("board"), Ident("currentTurn"), Ident("playerSymbol"), Ident("aiData"), Ident("moveRow"), Ident("moveColumn")])), Declaration(Bool, "_", Call("notifyMoveHuman", [Ident("board"), Ident("currentTurn"), Ident("playerSymbol"), Ident("moveRow"), Ident("moveColumn")]))), Return(BoolLiter(true))) }, Func { ident: "oppositeSymbol", signature: FuncSig { params: [(Char, "symbol")], return_type: Char }, body: If(BinaryApp(Ident("symbol"), Eq, CharLiter('x')), Return(CharLiter('o')), If(BinaryApp(Ident("symbol"), Eq, CharLiter('o')), Return(CharLiter('x')), Sequence(Println(StrLiter("Internal Error: symbol given is neither 'x' or 'o'")), Exit(IntLiter(-1))))) }, Func { ident: "symbolAt", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Int, "row"), (Int, "column")], return_type: Char }, body: Sequence(Declaration(Pair(Pair(Any, Any), Char), "targetRow", Expr(PairLiter)), Sequence(If(BinaryApp(Ident("row"), Lte, IntLiter(2)), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("board")))), If(BinaryApp(Ident("row"), Eq, IntLiter(1)), Assignment(Ident("targetRow"), PairElem(Fst(Ident("front")))), Assignment(Ident("targetRow"), PairElem(Snd(Ident("front")))))), Assignment(Ident("targetRow"), PairElem(Snd(Ident("board"))))), Sequence(Declaration(Char, "targetCell", Expr(CharLiter('\u{0}'))), Sequence(If(BinaryApp(Ident("column"), Lte, IntLiter(2)), Sequence(Declaration(Pair(Char, Char), "front", PairElem(Fst(Ident("targetRow")))), If(BinaryApp(Ident("column"), Eq, IntLiter(1)), Assignment(Ident("targetCell"), PairElem(Fst(Ident("front")))), Assignment(Ident("targetCell"), PairElem(Snd(Ident("front")))))), Assignment(Ident("targetCell"), PairElem(Snd(Ident("targetRow"))))), Return(Ident("targetCell")))))) }, Func { ident: "containEmptyCell", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("board")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row3", PairElem(Snd(Ident("board")))), Sequence(Declaration(Bool, "row1ContainEmpty", Call("containEmptyCellRow", [Ident("row1")])), Sequence(Declaration(Bool, "row2ContainEmpty", Call("containEmptyCellRow", [Ident("row2")])), Sequence(Declaration(Bool, "row3ContainEmpty", Call("containEmptyCellRow", [Ident("row3")])), Return(BinaryApp(Ident("row1ContainEmpty"), Or, BinaryApp(Ident("row2ContainEmpty"), Or, Ident("row3ContainEmpty"))))))))))) }, Func { ident: "containEmptyCellRow", signature: FuncSig { params: [(Pair(Pair(Any, Any), Char), "row")], return_type: Bool }, body: Sequence(Declaration(Pair(Char, Char), "front", PairElem(Fst(Ident("row")))), Sequence(Declaration(Char, "cell1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Char, "cell2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Char, "cell3", PairElem(Snd(Ident("row")))), Return(BinaryApp(BinaryApp(Ident("cell1"), Eq, CharLiter('\u{0}')), Or, BinaryApp(BinaryApp(Ident("cell2"), Eq, CharLiter('\u{0}')), Or, BinaryApp(Ident("cell3"), Eq, CharLiter('\u{0}'))))))))) }, Func { ident: "hasWon", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board"), (Char, "candidate")], return_type: Bool }, body: Sequence(Declaration(Char, "c11", Call("symbolAt", [Ident("board"), IntLiter(1), IntLiter(1)])), Sequence(Declaration(Char, "c12", Call("symbolAt", [Ident("board"), IntLiter(1), IntLiter(2)])), Sequence(Declaration(Char, "c13", Call("symbolAt", [Ident("board"), IntLiter(1), IntLiter(3)])), Sequence(Declaration(Char, "c21", Call("symbolAt", [Ident("board"), IntLiter(2), IntLiter(1)])), Sequence(Declaration(Char, "c22", Call("symbolAt", [Ident("board"), IntLiter(2), IntLiter(2)])), Sequence(Declaration(Char, "c23", Call("symbolAt", [Ident("board"), IntLiter(2), IntLiter(3)])), Sequence(Declaration(Char, "c31", Call("symbolAt", [Ident("board"), IntLiter(3), IntLiter(1)])), Sequence(Declaration(Char, "c32", Call("symbolAt", [Ident("board"), IntLiter(3), IntLiter(2)])), Sequence(Declaration(Char, "c33", Call("symbolAt", [Ident("board"), IntLiter(3), IntLiter(3)])), Return(BinaryApp(BinaryApp(BinaryApp(Ident("c11"), Eq, Ident("candidate")), And, BinaryApp(BinaryApp(Ident("c12"), Eq, Ident("candidate")), And, BinaryApp(Ident("c13"), Eq, Ident("candidate")))), Or, BinaryApp(BinaryApp(BinaryApp(Ident("c21"), Eq, Ident("candidate")), And, BinaryApp(BinaryApp(Ident("c22"), Eq, Ident("candidate")), And, BinaryApp(Ident("c23"), Eq, Ident("candidate")))), Or, BinaryApp(BinaryApp(BinaryApp(Ident("c31"), Eq, Ident("candidate")), And, BinaryApp(BinaryApp(Ident("c32"), Eq, Ident("candidate")), And, BinaryApp(Ident("c33"), Eq, Ident("candidate")))), Or, BinaryApp(BinaryApp(BinaryApp(Ident("c11"), Eq, Ident("candidate")), And, BinaryApp(BinaryApp(Ident("c21"), Eq, Ident("candidate")), And, BinaryApp(Ident("c31"), Eq, Ident("candidate")))), Or, BinaryApp(BinaryApp(BinaryApp(Ident("c12"), Eq, Ident("candidate")), And, BinaryApp(BinaryApp(Ident("c22"), Eq, Ident("candidate")), And, BinaryApp(Ident("c32"), Eq, Ident("candidate")))), Or, BinaryApp(BinaryApp(BinaryApp(Ident("c13"), Eq, Ident("candidate")), And, BinaryApp(BinaryApp(Ident("c23"), Eq, Ident("candidate")), And, BinaryApp(Ident("c33"), Eq, Ident("candidate")))), Or, BinaryApp(BinaryApp(BinaryApp(Ident("c11"), Eq, Ident("candidate")), And, BinaryApp(BinaryApp(Ident("c22"), Eq, Ident("candidate")), And, BinaryApp(Ident("c33"), Eq, Ident("candidate")))), Or, BinaryApp(BinaryApp(Ident("c13"), Eq, Ident("candidate")), And, BinaryApp(BinaryApp(Ident("c22"), Eq, Ident("candidate")), And, BinaryApp(Ident("c31"), Eq, Ident("candidate"))))))))))))))))))))) }, Func { ident: "allocateNewBoard", signature: FuncSig { params: [], return_type: Pair(Pair(Any, Any), Pair(Any, Any)) }, body: Sequence(Declaration(Pair(Pair(Any, Any), Char), "row1", Call("allocateNewRow", [])), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row2", Call("allocateNewRow", [])), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row3", Call("allocateNewRow", [])), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", Pair(Ident("row1"), Ident("row2"))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "root", Pair(Ident("front"), Ident("row3"))), Return(Ident("root"))))))) }, Func { ident: "allocateNewRow", signature: FuncSig { params: [], return_type: Pair(Pair(Any, Any), Char) }, body: Sequence(Declaration(Pair(Char, Char), "front", Pair(CharLiter('\u{0}'), CharLiter('\u{0}'))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "root", Pair(Ident("front"), CharLiter('\u{0}'))), Return(Ident("root")))) }, Func { ident: "freeBoard", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "board")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("board")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Char), "row3", PairElem(Snd(Ident("board")))), Sequence(Declaration(Bool, "_", Call("freeRow", [Ident("row1")])), Sequence(Assignment(Ident("_"), Call("freeRow", [Ident("row2")])), Sequence(Assignment(Ident("_"), Call("freeRow", [Ident("row3")])), Sequence(Free(Ident("front")), Sequence(Free(Ident("board")), Return(BoolLiter(true))))))))))) }, Func { ident: "freeRow", signature: FuncSig { params: [(Pair(Pair(Any, Any), Char), "row")], return_type: Bool }, body: Sequence(Declaration(Pair(Char, Char), "front", PairElem(Fst(Ident("row")))), Sequence(Free(Ident("front")), Sequence(Free(Ident("row")), Return(BoolLiter(true))))) }, Func { ident: "printAiData", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "aiData")], return_type: Bool }, body: Sequence(Declaration(Pair(Char, Pair(Any, Any)), "info", PairElem(Fst(Ident("aiData")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "stateTree", PairElem(Snd(Ident("aiData")))), Sequence(Declaration(Bool, "_", Call("printStateTreeRecursively", [Ident("stateTree")])), Exit(IntLiter(0))))) }, Func { ident: "printStateTreeRecursively", signature: FuncSig { params: [(Pair(Pair(Any, Any), Int), "stateTree")], return_type: Bool }, body: If(BinaryApp(Ident("stateTree"), Eq, PairLiter), Return(BoolLiter(true)), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("stateTree")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "board", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers", PairElem(Snd(Ident("front")))), Sequence(Declaration(Int, "value", PairElem(Snd(Ident("stateTree")))), Sequence(Print(CharLiter('v')), Sequence(Print(CharLiter('=')), Sequence(Println(Ident("value")), Sequence(Declaration(Bool, "_", Call("printBoard", [Ident("board")])), Sequence(Assignment(Ident("_"), Call("printChildrenStateTree", [Ident("pointers")])), Sequence(Println(CharLiter('p')), Return(BoolLiter(true))))))))))))) }, Func { ident: "printChildrenStateTree", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "pointers")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("pointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "row3", PairElem(Snd(Ident("pointers")))), Sequence(Declaration(Bool, "_", Call("printChildrenStateTreeRow", [Ident("row1")])), Sequence(Assignment(Ident("_"), Call("printChildrenStateTreeRow", [Ident("row2")])), Sequence(Assignment(Ident("_"), Call("printChildrenStateTreeRow", [Ident("row3")])), Return(BoolLiter(true))))))))) }, Func { ident: "printChildrenStateTreeRow", signature: FuncSig { params: [(Pair(Pair(Any, Any), Pair(Any, Any)), "rowPointers")], return_type: Bool }, body: Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "front", PairElem(Fst(Ident("rowPointers")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "cell1", PairElem(Fst(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "cell2", PairElem(Snd(Ident("front")))), Sequence(Declaration(Pair(Pair(Any, Any), Int), "cell3", PairElem(Snd(Ident("rowPointers")))), Sequence(Declaration(Bool, "_", Call("printStateTreeRecursively", [Ident("cell1")])), Sequence(Assignment(Ident("_"), Call("printStateTreeRecursively", [Ident("cell2")])), Sequence(Assignment(Ident("_"), Call("printStateTreeRecursively", [Ident("cell3")])), Return(BoolLiter(true))))))))) }], statement: Sequence(Declaration(Char, "playerSymbol", Call("chooseSymbol", [])), Sequence(Declaration(Char, "aiSymbol", Call("oppositeSymbol", [Ident("playerSymbol")])), Sequence(Declaration(Char, "currentTurn", Expr(CharLiter('x'))), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "board", Call("allocateNewBoard", [])), Sequence(Println(StrLiter("Initialising AI. Please wait, this may take a few minutes.")), Sequence(Declaration(Pair(Pair(Any, Any), Pair(Any, Any)), "aiData", Call("initAI", [Ident("aiSymbol")])), Sequence(Declaration(Int, "turnCount", Expr(IntLiter(0))), Sequence(Declaration(Char, "winner", Expr(CharLiter('\u{0}'))), Sequence(Declaration(Bool, "_", Call("printBoard", [Ident("board")])), Sequence(While(BinaryApp(BinaryApp(Ident("winner"), Eq, CharLiter('\u{0}')), And, BinaryApp(Ident("turnCount"), Lt, IntLiter(9))), Sequence(Declaration(Array(Int), "move", ArrayLiter(ArrayLiter([IntLiter(0), IntLiter(0)]))), Sequence(Assignment(Ident("_"), Call("askForAMove", [Ident("board"), Ident("currentTurn"), Ident("playerSymbol"), Ident("aiData"), Ident("move")])), Sequence(Assignment(Ident("_"), Call("placeMove", [Ident("board"), Ident("currentTurn"), ArrayElem(ArrayElem("move", [IntLiter(0)])), ArrayElem(ArrayElem("move", [IntLiter(1)]))])), Sequence(Assignment(Ident("_"), Call("notifyMove", [Ident("board"), Ident("currentTurn"), Ident("playerSymbol"), Ident("aiData"), ArrayElem(ArrayElem("move", [IntLiter(0)])), ArrayElem(ArrayElem("move", [IntLiter(1)]))])), Sequence(Assignment(Ident("_"), Call("printBoard", [Ident("board")])), Sequence(Declaration(Bool, "won", Call("hasWon", [Ident("board"), Ident("currentTurn")])), Sequence(If(Ident("won"), Assignment(Ident("winner"), Expr(Ident("currentTurn"))), Skip), Sequence(Assignment(Ident("currentTurn"), Call("oppositeSymbol", [Ident("currentTurn")])), Assignment(Ident("turnCount"), Expr(BinaryApp(Ident("turnCount"), Add, IntLiter(1))))))))))))), Sequence(Assignment(Ident("_"), Call("freeBoard", [Ident("board")])), Sequence(Assignment(Ident("_"), Call("destroyAI", [Ident("aiData")])), If(BinaryApp(Ident("winner"), Neq, CharLiter('\u{0}')), Sequence(Print(Ident("winner")), Println(StrLiter(" has won!"))), Println(StrLiter("Stalemate!"))))))))))))))) }.generate(_, 4):
